name: CARTO Upstream Sync - Conflict Resolver # do not change the name since is referenced in the ci-fixer workflow

# This workflow uses Claude Code to automatically resolve merge conflicts
# for upstream sync PRs, pushing resolution directly to the sync branch.
#
# Architecture (Single-PR, Deterministic):
#   1. Workflow starts merge (HARDCODED) - brings conflicts into working tree
#   2. Claude edits files ONLY - resolves conflict markers
#   3. Workflow completes merge commit (HARDCODED) - preserves both parents
#   4. Workflow pushes to sync branch (HARDCODED) - updates existing PR
#
# This ensures:
#   - Single PR workflow (no separate resolution PR)
#   - Merge commit always has both parents (upstream with main tag checkout + carto/main)
#   - Git operations are deterministic (not dependent on Claude's actions)
#
# Security features:
# - Only runs when triggered by authorized users (Cartofante, mateo-di)
# - Only runs on PRs labeled 'upstream-sync'
# - Only runs on upstream-sync/* branches (not main directly)
# - Only runs when conflicts are detected
# - Blocks external forks
# - Rate limited (max-turns: 250, job timeout: 90 mins)

on:
  pull_request:
    types: [opened, labeled, synchronize]
    branches:
      - carto/main
  workflow_dispatch:
    inputs:
      pr-number:
        description: "PR number to resolve conflicts for"
        required: true
        default: ""
      debug:
        description: "Enable debug logging"
        type: boolean
        default: false

# Prevent duplicate runs on the same PR
# IMPORTANT: Uses shared concurrency group with CI Fixer to prevent both running simultaneously
concurrency:
  group: upstream-sync-${{ github.event.pull_request.number || github.event.inputs.pr-number || github.run_id }}
  cancel-in-progress: false  # Wait for running workflow to finish (don't cancel)

permissions:
  contents: write      
  pull-requests: write

jobs:
  # Job 1: Security verification - MUST PASS before any other checks
  security-check:
    name: Security Verification
    runs-on: ubuntu-latest

    outputs:
      authorized: ${{ steps.verify.outputs.authorized }}

    steps:
      - name: Verify actor and PR source
        id: verify
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eu

          echo "::group::Security verification"

          # Security Check 1: Only allow specific authorized users
          ACTOR="${{ github.actor }}"
          ALLOWED_ACTORS="Cartofante mateo-di"

          # Check if actor is in allowed list (case-insensitive)
          ACTOR_LOWER="${ACTOR,,}"
          ALLOWED=false
          for allowed in ${ALLOWED_ACTORS}; do
            if [[ "${ACTOR_LOWER}" == "${allowed,,}" ]]; then
              ALLOWED=true
              break
            fi
          done

          if [[ "${ALLOWED}" == "false" ]]; then
            echo "[Security] ‚ùå Unauthorized actor: ${ACTOR}"
            echo "[Security] Allowed actors: ${ALLOWED_ACTORS}"
            echo "authorized=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "[Security] ‚úÖ Actor verified: ${ACTOR}"

          # Security Check 2: Verify branch flow (main ‚Üí carto/main)
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # Automatic trigger: validate PR directly from event
            HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"
            BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
            HEAD_REPO="${{ github.event.pull_request.head.repo.full_name }}"
            BASE_REPO="${{ github.repository }}"

            # Check fork - head repo must match base repo
            if [[ "${HEAD_REPO}" != "${BASE_REPO}" ]]; then
              echo "[Security] ‚ùå External fork detected: ${HEAD_REPO}"
              echo "[Security] Only internal branches allowed"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ PR source verified: internal branch"

            # Check branch flow - allow upstream-sync/* branches
            if [[ ! "${HEAD_BRANCH}" =~ ^upstream-sync/ ]] || [[ "${BASE_BRANCH}" != "carto/main" ]]; then
              echo "[Security] ‚ùå Invalid branch flow: ${HEAD_BRANCH} ‚Üí ${BASE_BRANCH}"
              echo "[Security] Required: upstream-sync/* ‚Üí carto/main"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ Branch flow verified: ${HEAD_BRANCH} ‚Üí carto/main"
          else
            # Manual trigger: fetch PR details via gh CLI
            PR_NUMBER="${{ github.event.inputs.pr-number }}"
            if [[ -z "${PR_NUMBER}" ]]; then
              echo "[Security] ‚ùå PR number required for manual dispatch"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "[Security] Manual dispatch for PR #${PR_NUMBER}"

            # Fetch PR details
            PR_JSON=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json headRefName,baseRefName,headRepositoryOwner,isCrossRepository)
            HEAD_BRANCH=$(echo "${PR_JSON}" | jq -r '.headRefName')
            BASE_BRANCH=$(echo "${PR_JSON}" | jq -r '.baseRefName')
            IS_FORK=$(echo "${PR_JSON}" | jq -r '.isCrossRepository')

            # Check fork - isCrossRepository is true for external forks
            if [[ "${IS_FORK}" == "true" ]]; then
              REPO_OWNER=$(echo "${PR_JSON}" | jq -r '.headRepositoryOwner.login')
              echo "[Security] ‚ùå External fork detected from: ${REPO_OWNER}"
              echo "[Security] Only internal branches allowed"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ PR source verified: internal branch"

            # Check branch flow - allow upstream-sync/* branches
            if [[ ! "${HEAD_BRANCH}" =~ ^upstream-sync/ ]] || [[ "${BASE_BRANCH}" != "carto/main" ]]; then
              echo "[Security] ‚ùå Invalid branch flow: ${HEAD_BRANCH} ‚Üí ${BASE_BRANCH}"
              echo "[Security] Required: upstream-sync/* ‚Üí carto/main"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ Branch flow verified: ${HEAD_BRANCH} ‚Üí carto/main"
          fi

          # All security checks passed
          echo "[Security] ‚úÖ All security checks passed"
          echo "authorized=true" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  # Job 2: Check if this PR is eligible for automated conflict resolution
  check-eligibility:
    name: Check PR Eligibility
    runs-on: ubuntu-latest
    needs: security-check
    if: needs.security-check.outputs.authorized == 'true'

    outputs:
      eligible: ${{ steps.check.outputs.eligible }}
      pr-number: ${{ steps.check.outputs.pr-number }}
      has-conflicts: ${{ steps.check.outputs.has-conflicts }}
      is-sync-pr: ${{ steps.check.outputs.is-sync-pr }}

    steps:
      - name: Check PR criteria
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eu

          # Get PR number based on trigger type
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
          else
            PR_NUMBER="${{ github.event.inputs.pr-number }}"
          fi

          echo "::group::Checking PR eligibility for conflict resolution"
          echo "[Resolver] Checking PR #${PR_NUMBER}"

          # Get PR details
          PR_JSON=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json labels,mergeable,headRefName,baseRefName)

          # Extract details
          echo "${PR_JSON}"
          BASE_BRANCH=$(echo "${PR_JSON}" | jq -r '.baseRefName')
          echo "BASE_BRANCH: ${BASE_BRANCH}"
          HEAD_BRANCH=$(echo "${PR_JSON}" | jq -r '.headRefName')
          echo "HEAD_BRANCH: ${HEAD_BRANCH}"
          MERGEABLE=$(echo "${PR_JSON}" | jq -r '.mergeable')
          echo "MERGEABLE: ${MERGEABLE}"
          LABELS=$(echo "${PR_JSON}" | jq -r '.labels[].name' | tr '\n' ' ')
          # Use jq for exact label matching (avoid substring matches)
          HAS_UPSTREAM_SYNC=$(echo "${PR_JSON}" | jq '[.labels[].name] | any(. == "upstream-sync")')
          echo "LABELS: ${LABELS}"

          echo "[Resolver] Base: ${BASE_BRANCH}, Head: ${HEAD_BRANCH}"
          echo "[Resolver] Mergeable status: ${MERGEABLE}"
          echo "[Resolver] Labels: ${LABELS}"

          # Check 1: Must be to carto/main
          if [[ "${BASE_BRANCH}" != "carto/main" ]]; then
            echo "[Resolver] ‚ùå Not targeting carto/main - skipping"
            echo "eligible=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check 2: Must have upstream-sync label (exact match)
          if [[ "${HAS_UPSTREAM_SYNC}" != "true" ]]; then
            echo "[Resolver] ‚ùå Missing 'upstream-sync' label - skipping"
            echo "is-sync-pr=false" >> $GITHUB_OUTPUT
            echo "eligible=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "is-sync-pr=true" >> $GITHUB_OUTPUT

          # Check 3: Must have conflicts (or manual trigger)
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual trigger: skip conflict check (user knows there are conflicts)
            echo "[Resolver] ‚ö†Ô∏è Manual trigger - skipping conflict check (status: ${MERGEABLE})"
            echo "[Resolver] Assuming conflicts exist (user manually triggered)"
            echo "has-conflicts=true" >> $GITHUB_OUTPUT
          elif [[ "${MERGEABLE}" == "CONFLICTING" ]]; then
            # Automatic trigger: conflicts detected
            echo "[Resolver] ‚ö†Ô∏è Conflicts detected (mergeable: ${MERGEABLE})"
            echo "has-conflicts=true" >> $GITHUB_OUTPUT
          elif [[ "${MERGEABLE}" == "UNKNOWN" ]]; then
            # Status not computed yet - treat as potential conflict
            echo "[Resolver] ‚ö†Ô∏è Mergeable status unknown - will attempt resolution"
            echo "has-conflicts=true" >> $GITHUB_OUTPUT
          else
            # Clean merge - no action needed
            echo "[Resolver] ‚úÖ No conflicts detected (mergeable: ${MERGEABLE})"
            echo "has-conflicts=false" >> $GITHUB_OUTPUT
            echo "eligible=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # All checks passed
          echo "[Resolver] ‚úÖ PR is eligible for conflict resolution"
          echo "eligible=true" >> $GITHUB_OUTPUT
          echo "pr-number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  # Job 3: Use Claude Code to resolve conflicts
  claude-resolve:
    name: Claude Code Conflict Resolution
    runs-on: ubuntu-latest
    timeout-minutes: 90  # Job timeout is the real limit (not max-turns)
    needs: [security-check, check-eligibility]
    if: needs.security-check.outputs.authorized == 'true' && needs.check-eligibility.outputs.eligible == 'true'

    steps:
      - name: Get PR branch info
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          # Get head and base refs based on trigger type
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            HEAD_REF="${{ github.event.pull_request.head.ref }}"
            BASE_REF="${{ github.event.pull_request.base.ref }}"
          else
            # For workflow_dispatch, fetch from PR
            PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"
            PR_JSON=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json headRefName,baseRefName)
            HEAD_REF=$(echo "${PR_JSON}" | jq -r '.headRefName')
            BASE_REF=$(echo "${PR_JSON}" | jq -r '.baseRefName')
          fi

          echo "head-ref=${HEAD_REF}" >> $GITHUB_OUTPUT
          echo "base-ref=${BASE_REF}" >> $GITHUB_OUTPUT
          echo "[Resolver] PR: ${HEAD_REF} ‚Üí ${BASE_REF}"
          echo "[Resolver] Will checkout sync branch (${HEAD_REF}) and merge ${BASE_REF} into it"
          echo "[Resolver] Resolution commits will be pushed directly to this PR's branch"

      # IMPORTANT: Checkout the sync branch (upstream-sync/vX.Y.Z) which has upstream commit history
      # Then merge BASE branch (carto/main) into it to bring CARTO customizations
      # Resolution commits are pushed directly to this branch, updating the existing PR
      - name: Checkout repository (sync branch - upstream with history)
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr-info.outputs.head-ref }}
          fetch-depth: 0
          token: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}

      - name: Configure git
        run: |
          git config --global user.name "Cartofante"
          git config --global user.email "cartofante@carto.com"

      - name: Check sync-required files status
        id: sync-check
        run: |
          echo "::group::Checking sync-required files"

          # Files that MUST stay in sync with upstream (accept upstream version)
          SYNC_FILES="schema.prisma"

          HEAD_REF="${{ steps.pr-info.outputs.head-ref }}"

          for FILE in $SYNC_FILES; do
            if [ -f "$FILE" ]; then
              # Compare with upstream version from this branch (which has upstream content)
              CURRENT_LINES=$(wc -l < $FILE | tr -d ' ')
              echo "[Resolver] $FILE: $CURRENT_LINES lines (current)"

              # Store sync-required files list for Claude
              echo "$FILE" >> /tmp/sync_required_files.txt
            fi
          done

          if [ -f /tmp/sync_required_files.txt ]; then
            echo "sync-files=$(cat /tmp/sync_required_files.txt | tr '\n' ' ')" >> $GITHUB_OUTPUT
          else
            echo "sync-files=" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

      - name: Start merge with carto/main (HARDCODED - creates conflicts)
        id: start-merge
        run: |
          echo "::group::Starting merge (WORKFLOW CONTROLLED)"
          echo "[Resolver] Strategy: Checkout ${HEAD_REF} (upstream) ‚Üí merge ${BASE_REF} (CARTO) into it"
          echo "[Resolver] This preserves upstream commit history in the PR"

          HEAD_REF="${{ steps.pr-info.outputs.head-ref }}"
          BASE_REF="${{ steps.pr-info.outputs.base-ref }}"

          # Fetch the base branch (carto/main with CARTO customizations)
          git fetch origin ${BASE_REF}:${BASE_REF}

          # Attempt merge of CARTO customizations into upstream
          # This is the REVERSE of the original PR direction, but preserves history
          if git merge ${BASE_REF} --no-commit --no-ff; then
            echo "[Resolver] ‚úÖ Clean merge - no conflicts found"
            echo "[Resolver] This PR should be mergeable without Claude's help"
            git merge --abort || true
            echo "has-conflicts=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "[Resolver] ‚ö†Ô∏è Conflicts detected - Claude will resolve file contents"

            # Save list of conflicted files for Claude
            CONFLICTS=$(git diff --name-only --diff-filter=U)
            echo "conflicts<<EOF" >> $GITHUB_OUTPUT
            echo "$CONFLICTS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            CONFLICT_COUNT=$(echo "$CONFLICTS" | wc -l)
            echo "conflict-count=${CONFLICT_COUNT}" >> $GITHUB_OUTPUT
            echo "has-conflicts=true" >> $GITHUB_OUTPUT

            echo "[Resolver] Conflicted files (${CONFLICT_COUNT}):"
            echo "$CONFLICTS"
          fi

          echo "::endgroup::"

      # =========================================================================
      # Auto-resolve build artifacts (accept upstream - CARTO doesn't customize these)
      # =========================================================================
      - name: Auto-resolve build artifacts (accept upstream)
        id: auto-resolve
        run: |
          echo "::group::Auto-resolving build artifacts"

          # Patterns for build artifacts and generated files
          # CARTO doesn't customize these - always accept upstream
          AUTO_RESOLVE_DIRS=(
            "litellm/proxy/_experimental/out/"
            "ui/litellm-dashboard/out/"
          )

          CONFLICTS=$(git diff --name-only --diff-filter=U 2>/dev/null || echo "")
          AUTO_RESOLVED=0

          for file in $CONFLICTS; do
            for dir in "${AUTO_RESOLVE_DIRS[@]}"; do
              if [[ "$file" == "$dir"* ]]; then
                echo "[Auto-resolve] Accepting upstream: $file"
                git checkout --theirs "$file" 2>/dev/null || true
                git add "$file" 2>/dev/null || true
                AUTO_RESOLVED=$((AUTO_RESOLVED + 1))
                break
              fi
            done
          done

          echo "[Auto-resolve] Resolved ${AUTO_RESOLVED} build artifact(s)"
          echo "auto-resolved=${AUTO_RESOLVED}" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Comment on PR - Starting
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          gh pr comment ${{ needs.check-eligibility.outputs.pr-number }} \
            --repo ${{ github.repository }} \
            --body "$(cat <<'EOF'
          ## ü§ñ Conflict Resolution Started

          **Status:** ‚è≥ In progress...

          Claude Code (Opus 4.5) is resolving merge conflicts in this PR.

          | Step | Status |
          |------|--------|
          | üîç Analyze conflicts | In progress |
          | ‚úèÔ∏è Resolve files | Pending |
          | üß™ Run tests | Pending |
          | üìå Push to PR | Pending |

          > [!NOTE]
          > This may take **30-90 minutes** for large PRs. Resolution commits will be pushed directly to this PR.

          <details>
          <summary>üìã Resolution Process (click to expand)</summary>

          1. üîç Analyzing conflicts in all files
          2. üìã Reading CARTO customization guidelines
          3. ‚öñÔ∏è Applying resolution priorities (CARTO first, then upstream)
          4. ‚úèÔ∏è Resolving conflicts file by file
          5. üß™ Running tests (lint, mypy, unit tests)
          6. üìå Pushing resolution directly to this PR

          </details>

          [View workflow run ‚Üí](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )"

      - name: Setup GCP credentials for Vertex AI
        run: |
          echo '${{ secrets.CI_RESOURCES_SERVICE_ACCOUNT }}' > /tmp/gcp-sa.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=/tmp/gcp-sa.json" >> $GITHUB_ENV

      # =========================================================================
      # CARTO PR Analysis - Identify files modified by CARTO org members
      # (Inlined because sync branches don't have .github/actions/)
      # =========================================================================
      - name: Analyze CARTO PRs for feature context
        id: carto-prs
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          echo "::group::Analyzing CARTO PRs for feature context"

          OUTPUT_PATH="/tmp/carto-analysis"
          mkdir -p "${OUTPUT_PATH}"

          # Step 1: Fetch CartoDB org members
          echo "[Resolver] Fetching CartoDB org members..."
          ORG_MEMBERS=$(gh api "orgs/CartoDB/members" --paginate --jq '.[].login' 2>/dev/null | tr '\n' '|' | sed 's/|$//')

          if [ -z "$ORG_MEMBERS" ]; then
            echo "[Resolver] Warning: Could not fetch org members, using fallback"
            ORG_MEMBERS="Cartofante|mateo-di"
          fi

          # Step 2: Fetch all merged PRs to carto/main
          echo "[Resolver] Fetching PRs merged to carto/main..."
          gh pr list \
            --repo ${{ github.repository }} \
            --base carto/main \
            --state merged \
            --limit 1000 \
            --json number,title,author,mergedAt,additions,deletions,files \
            > "${OUTPUT_PATH}/all_prs.json" 2>/dev/null || echo "[]" > "${OUTPUT_PATH}/all_prs.json"

          # Step 3: Filter to CARTO org member authors only (exclude upstream-sync PRs)
          jq --arg pattern "$ORG_MEMBERS" '
            [.[] |
              select(.author.login | test("^(" + $pattern + ")$"; "i")) |
              select(([(.labels // [])[].name] | any(. == "upstream-sync")) | not) |
              select(.title | test("^(sync:|upstream sync:|fix: resolve.*upstream|fix: resolve conflicts|fix\\(ci\\):|merge:)"; "i") | not) |
              select(.title | test("Upstream Sync:"; "i") | not)
            ]
          ' "${OUTPUT_PATH}/all_prs.json" > "${OUTPUT_PATH}/carto_prs.json"

          CARTO_PRS=$(jq 'length' "${OUTPUT_PATH}/carto_prs.json")
          echo "[Resolver] Found ${CARTO_PRS} CARTO feature PRs"

          rm -f "${OUTPUT_PATH}/all_prs.json"
          echo "carto-pr-count=${CARTO_PRS}" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Build CARTO feature context
        id: carto-context
        run: |
          echo "::group::Building CARTO feature context for Claude"

          CONFLICTS="${{ steps.start-merge.outputs.conflicts }}"
          CONFLICT_COUNT="${{ steps.start-merge.outputs.conflict-count }}"

          if [ -f /tmp/carto-analysis/carto_prs.json ]; then
            TOTAL_PRS=$(jq 'length' /tmp/carto-analysis/carto_prs.json)

            # Generate feature summaries - tells Claude WHAT features exist
            jq -r '
              sort_by(.mergedAt) | reverse | .[0:20] |
              .[] |
              "### PR #\(.number): \(.title)\n" +
              "- **Files:** \(.files[:3] | map(.path) | join(", "))\(if (.files | length) > 3 then " (+\(.files | length - 3) more)" else "" end)\n"
            ' /tmp/carto-analysis/carto_prs.json > /tmp/carto_features.md

            # Create file-to-PR mapping for conflicted files only
            echo "" > /tmp/carto_file_mapping.md
            echo "## Conflicted Files with CARTO History" >> /tmp/carto_file_mapping.md
            echo "(Files not listed here have no CARTO PRs - safe to sync from upstream)" >> /tmp/carto_file_mapping.md
            echo "" >> /tmp/carto_file_mapping.md

            for FILE in $CONFLICTS; do
              FILE_PRS=$(jq -r --arg f "$FILE" '
                [.[] | select(.files | map(.path) | any(. == $f))] |
                if length > 0 then
                  "- `" + $f + "` ‚Üê " + ([.[] | "PR #\(.number)"] | join(", "))
                else
                  empty
                end
              ' /tmp/carto-analysis/carto_prs.json)

              if [ -n "$FILE_PRS" ]; then
                echo "$FILE_PRS" >> /tmp/carto_file_mapping.md
              fi
            done

            echo "total-prs=${TOTAL_PRS}" >> $GITHUB_OUTPUT
          else
            echo "No CARTO PRs found" > /tmp/carto_features.md
            echo "No file mapping available" > /tmp/carto_file_mapping.md
            echo "total-prs=0" >> $GITHUB_OUTPUT
          fi

          echo "conflict-count=${CONFLICT_COUNT}" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Fetch PR comments for context
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          echo "::group::Fetching PR comments for previous resolution context"

          PR_NUMBER="${{ github.event.pull_request.number || github.event.inputs.pr-number }}"

          # Fetch all PR comments (includes previous resolution attempts, human feedback)
          gh pr view ${PR_NUMBER} \
            --repo ${{ github.repository }} \
            --json comments \
            --jq '.comments[] | "---\n**\(.author.login)** at \(.createdAt):\n\(.body)\n"' \
            > /tmp/pr_comments.md 2>/dev/null || echo "No comments found" > /tmp/pr_comments.md

          COMMENT_COUNT=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json comments --jq '.comments | length' 2>/dev/null || echo "0")
          echo "[Resolver] Found ${COMMENT_COUNT} PR comments for context"

          echo "::endgroup::"

      - name: Run Claude Code for conflict resolution (GOAL-DRIVEN)
        id: claude-run
        uses: anthropics/claude-code-action@v1
        with:
          use_vertex: "true"
          github_token: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
          show_full_output: true
          claude_args: "--model claude-opus-4-5@20251101 --max-turns 250 --allowedTools Read,Write,Edit,Bash,Grep,Glob ${{ github.event.inputs.debug == 'true' && '--debug' || '' }}"
          prompt: |
            # Upstream Sync Conflict Resolution

            ## YOUR PRIMARY GOAL

            **Make CI pass** while preserving CARTO features.

            You have FULL FREEDOM to decide how to resolve each conflict. The workflow trusts your judgment.
            There are no rigid per-file rules - you decide what makes sense for each situation.

            ---

            ## GIT CONTEXT (Important!)

            **Current branch:** ${{ steps.pr-info.outputs.head-ref }} (upstream TAG content, e.g., upstream-sync/v1.65.0)
            **Merging in:** ${{ steps.pr-info.outputs.base-ref }} (carto/main with CARTO customizations)

            This means:
            - **HEAD / `--ours`** = Upstream TAG version (the sync branch content)
            - **`--theirs`** = carto/main version (CARTO customizations)

            **Conflict markers:**
            ```
            <<<<<<< HEAD
            [upstream TAG code - from sync branch]
            =======
            [CARTO code - from carto/main]
            >>>>>>> carto/main
            ```

            ---

            ## STEP 0: FIX LOOP DETECTION (DO THIS FIRST!)

            Before resolving ANY conflicts, check for fix loops:

            ```bash
            cat /tmp/pr_comments.md | grep -iE "Added.*function|Added.*from upstream|sync.*file|ImportError|cannot import|fix:" | head -20
            ```

            **If same file appears 3+ times in previous fixes ‚Üí SYNC ENTIRE FILE from upstream TAG:**
            ```bash
            # Use HEAD which already has the upstream TAG content
            git show HEAD:path/to/problematic_file.py > path/to/problematic_file.py
            git add path/to/problematic_file.py
            ```

            This breaks the loop by accepting the complete upstream TAG version.

            ---

            ## CARTO FEATURES TO PRESERVE

            These are the INTENTIONAL CARTO customizations from merged PRs.
            **Preserve the BEHAVIOR, not necessarily the exact file versions.**

            Read the feature context:
            ```bash
            cat /tmp/carto_features.md
            ```

            And the file-to-PR mapping (shows which PRs touched which conflicted files):
            ```bash
            cat /tmp/carto_file_mapping.md
            ```

            For detailed PR information:
            ```bash
            gh pr view <PR_NUMBER> --repo ${{ github.repository }}
            ```

            ---

            ## SYNC-REQUIRED FILES (Always Accept Upstream TAG)

            These files MUST match upstream regardless of CARTO history:

            | File | Reason |
            |------|--------|
            | `schema.prisma` | Database schema MUST match LiteLLM code |
            | `litellm/proxy/schema.prisma` | Prisma schema |

            For these files, accept the upstream TAG version:
            ```bash
            git checkout --ours <file>  # --ours = HEAD = upstream TAG
            git add <file>
            ```

            ---

            ## CONFLICTED FILES (${{ steps.carto-context.outputs.conflict-count }} files)

            ```bash
            git diff --name-only --diff-filter=U
            ```

            ---

            ## RESOLUTION STRATEGY

            For each conflicted file, YOU DECIDE based on:

            | Pattern | Strategy |
            |---------|----------|
            | File implements a CARTO feature (check /tmp/carto_file_mapping.md) | Merge carefully - preserve feature code |
            | File is pure upstream (core lib, tests, no CARTO PRs) | Accept upstream: `git checkout --ours <file>` |
            | File has both CARTO and upstream changes | Merge BOTH - keep CARTO + add upstream |
            | ImportError for missing function | Check if in fix loop ‚Üí sync entire file from HEAD |
            | TypeScript module not found | Check if file path changed in upstream TAG |
            | File in `_experimental/out/` or `node_modules/` | Accept upstream (build artifacts) |

            ## KEY PRINCIPLE

            **Upstream TAG code WORKS** - it's from a tested stable release. If something is "missing",
            the conflict resolver probably kept an old carto/main version instead of the new upstream TAG.

            When in doubt: Compare file sizes. Bigger = usually newer = probably correct.

            ---

            ## ERROR PATTERN REFERENCE

            | Error Pattern | Root Cause | Fix |
            |--------------|------------|-----|
            | `Type error: Expected X arguments` | Function signature changed in upstream | Update call site OR sync file |
            | `Cannot find module 'X'` | File renamed/moved in upstream TAG | Update import path |
            | `ImportError: cannot import name 'X'` | File outdated, missing upstream changes | `git show HEAD:<file> > <file>` |
            | `'Prisma' object has no attribute` | schema.prisma out of sync | `git checkout --ours schema.prisma` |
            | `SyntaxError` | Conflict markers left in file | Search for `<<<<<<<` |
            | `AssertionError` in tests | Test expects old behavior | Update test expectation |

            ---

            ## GIT COMMANDS REFERENCE

            ```bash
            # Accept upstream TAG version (HEAD/--ours):
            git checkout --ours path/to/file.py
            git add path/to/file.py

            # Accept CARTO version (--theirs):
            git checkout --theirs path/to/file.py
            git add path/to/file.py

            # View upstream TAG version without replacing:
            git show HEAD:path/to/file.py | head -50

            # View CARTO version without replacing:
            git show carto/main:path/to/file.py | head -50
            ```

            ---

            ## VERIFICATION (Before Saying Done)

            Run Docker build to catch ALL errors at once:
            ```bash
            docker build -f docker/Dockerfile.non_root . 2>&1 | tail -100
            ```

            Iterate until success:
            1. Fix error
            2. Run Docker build again
            3. Repeat until no errors

            Also run:
            ```bash
            # Check no conflict markers remain
            grep -rE "^(<{7}|>{7}|={7})[[:space:]]" --include="*.py" --include="*.ts" litellm/ tests/ || echo "‚úÖ No markers"

            # Quick lint check
            make lint-ruff || true
            ```

            ---

            ## WORKFLOW HANDLES THESE (DO NOT RUN)

            - ‚ùå `git commit` - Workflow does this
            - ‚ùå `git push` - Workflow does this
            - ‚ùå `gh pr create` - Not needed, pushing to existing PR

            ---

            ## SAY "RESOLUTION COMPLETE" WHEN DONE

            When all conflicts are resolved and verification passes, say exactly:

            **"RESOLUTION COMPLETE"**

            The workflow will then stage, commit, and push to this PR.

        env:
          ANTHROPIC_VERTEX_PROJECT_ID: carto-ci-resources
          CLOUD_ML_REGION: global
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
          GITHUB_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}

      - name: Cleanup GCP credentials
        if: always()
        run: rm -f /tmp/gcp-sa.json

      # =========================================================================
      # Post-resolution verification (simplified for goal-driven approach)
      # The real verification is: Does CI pass? If yes, resolution is good.
      # =========================================================================
      - name: Quick sanity check
        id: sanity-check
        run: |
          echo "::group::Quick sanity check"

          # Check for any remaining conflict markers
          MARKERS=$(grep -rE "^(<{7}|>{7}|={7})" --include="*.py" --include="*.ts" litellm/ tests/ 2>/dev/null | head -5 || echo "")

          if [ -n "$MARKERS" ]; then
            echo "::warning::Possible conflict markers found:"
            echo "$MARKERS"
            echo "has-issues=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ No conflict markers found"
            echo "has-issues=false" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

      # ============================================================
      # POST-CLAUDE: Complete merge, create branch, push, create PR
      # These steps are HARDCODED to ensure correct git operations
      # ============================================================

      - name: Verify no conflict markers remain
        id: verify-resolution
        run: |
          echo "::group::Verifying conflict resolution"

          # Check for conflict markers in source files
          # Use specific patterns to avoid false positives (markdown dividers like ====)
          # Real conflict markers: <<<<<<< HEAD, =======, >>>>>>> branch

          FOUND_MARKERS=$(grep -rE "^(<{7}|>{7}|={7})[[:space:]]" \
            --include="*.py" \
            --include="*.yaml" --include="*.yml" \
            --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" \
            --include="*.toml" \
            --include="*.prisma" \
            --include="*.json" \
            . 2>/dev/null \
            | grep -v ".git" \
            | grep -v "_experimental/out/" \
            | grep -v "node_modules/" \
            || echo "")

          if [ -n "$FOUND_MARKERS" ]; then
            echo "‚ùå ERROR: Conflict markers still present!"
            echo "$FOUND_MARKERS"
            echo "Claude did not fully resolve all conflicts."
            echo "resolved=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "‚úÖ No conflict markers found"
          echo "resolved=true" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Complete merge commit (HARDCODED - creates merge with both parents)
        id: complete-merge
        if: steps.verify-resolution.outputs.resolved == 'true'
        run: |
          echo "::group::Completing merge commit (WORKFLOW CONTROLLED)"

          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"

          # Stage all resolved files
          git add -A

          # Complete the merge - this creates a MERGE COMMIT with BOTH parents:
          # - Parent 1: main (upstream with main tag checkout)
          # - Parent 2: carto/main (CARTO customizations)
          git commit -m "fix: resolve upstream sync conflicts for PR #${PR_NUMBER}

          Conflicts resolved by Claude Code following CARTO priority rules.

          Resolution strategy:
          - Preserved CARTO customizations (workflows, docs, infrastructure)
          - Accepted upstream improvements (core litellm, tests, dependencies)
          - Manually merged mixed files (Dockerfile, Makefile)

          This is a MERGE COMMIT with both main and carto/main as parents,
          preserving full git history from upstream.

          Resolves: #${PR_NUMBER}"

          # Verify we created a merge commit (should have 2 parents)
          PARENT_COUNT=$(git cat-file -p HEAD | grep "^parent" | wc -l)
          if [ "$PARENT_COUNT" -lt 2 ]; then
            echo "‚ö†Ô∏è WARNING: Commit has only ${PARENT_COUNT} parent(s), expected 2 for merge commit"
          else
            echo "‚úÖ Merge commit created with ${PARENT_COUNT} parents"
          fi

          echo "merge-commit=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Push resolution to sync branch (HARDCODED - updates existing PR)
        id: push-resolution
        if: steps.verify-resolution.outputs.resolved == 'true'
        run: |
          echo "::group::Pushing resolution to sync branch (WORKFLOW CONTROLLED)"

          HEAD_REF="${{ steps.pr-info.outputs.head-ref }}"
          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"

          # Push directly to the sync branch - this updates the existing PR!
          # No need to create a new branch or PR
          echo "[Resolver] Pushing merge commit to ${HEAD_REF}..."
          git push origin HEAD:${HEAD_REF}

          echo "‚úÖ Pushed resolution to: ${HEAD_REF}"
          echo "‚úÖ PR #${PR_NUMBER} will automatically update with the resolved changes"
          echo "branch-name=${HEAD_REF}" >> $GITHUB_OUTPUT
          echo "::endgroup::"
    
      - name: Check if more conflicts remain after push
        id: check-remaining
        if: steps.push-resolution.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          echo "::group::Checking if PR still has conflicts"

          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"

          # Wait for GitHub to compute mergeable status
          sleep 10

          MERGEABLE=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json mergeable --jq '.mergeable')
          echo "[Resolver] PR mergeable status: ${MERGEABLE}"

          if [[ "${MERGEABLE}" == "CONFLICTING" ]]; then
            echo "[Resolver] PR still has conflicts - retriggering resolver"
            gh workflow run carto-upstream-sync-resolver.yml \
              --repo ${{ github.repository }} \
              -f pr-number=${PR_NUMBER}
            echo "retriggered=true" >> $GITHUB_OUTPUT
          else
            echo "[Resolver] PR is clean - no retrigger needed"
            echo "retriggered=false" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"
          
      - name: Summary
        if: always()
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          echo "::group::Workflow Execution Summary"
          echo "[Resolver] Conflict resolution workflow completed"
          echo "[Resolver] Claude edited files, workflow pushed to existing PR"
          echo "::endgroup::"

          # Get PR URL for the summary
          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"
          PR_URL=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json url --jq '.url')

          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ü§ñ Conflict Resolution Summary

          **PR Updated:** ${PR_URL}
          **Sync Branch:** ${{ steps.push-resolution.outputs.branch-name || 'N/A' }}

          ### Workflow Architecture (Single-PR, Deterministic)

          | Step | Handled By | Status |
          |------|------------|--------|
          | Start merge | Workflow | ‚úÖ |
          | Resolve conflicts | Claude Code | ${{ steps.claude-run.outcome == 'success' && '‚úÖ' || '‚ùå' }} |
          | Verify no markers | Workflow | ${{ steps.verify-resolution.outcome == 'success' && '‚úÖ' || '‚ùå' }} |
          | Sanity check | Workflow | ${{ steps.sanity-check.outputs.has-issues == 'false' && '‚úÖ' || '‚ö†Ô∏è' }} |
          | Create merge commit | Workflow | ${{ steps.complete-merge.outcome == 'success' && '‚úÖ' || '‚ùå' }} |
          | Push to sync branch | Workflow | ${{ steps.push-resolution.outcome == 'success' && '‚úÖ' || '‚ùå' }} |

          ### Key Improvements

          1. **Single-PR workflow** - No separate resolution PR, changes pushed directly to sync branch
          2. **Deterministic** - Git operations are hardcoded in workflow, not in Claude's prompt
          3. **Merge commit preserved** - Both parents (upstream + carto/main) for proper history

          **Merge commit:** \`${{ steps.complete-merge.outputs.merge-commit || 'N/A' }}\`
          EOF

      - name: Comment on PR - Completion
        if: always()
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"
          PUSH_SUCCESS="${{ steps.push-resolution.outcome }}"

          if [ "${PUSH_SUCCESS}" == "success" ]; then
            # Success - resolution pushed to sync branch
            gh pr comment ${PR_NUMBER} \
              --repo ${{ github.repository }} \
              --body "$(cat <<EOF
          ## ‚úÖ Conflict Resolution Complete

          All conflicts resolved and pushed to this PR.

          | Step | Status |
          |------|--------|
          | üîç Analyze conflicts | ‚úÖ Complete |
          | ‚úèÔ∏è Resolve files | ‚úÖ Complete |
          | üß™ Verify resolution | ‚úÖ Complete |
          | üìå Push to PR | ‚úÖ Complete |

          > [!IMPORTANT]
          > **Ready to merge!** Use **"Create a merge commit"** ‚Äî do NOT squash or rebase.

          ### Next Steps

          1. Review the resolved changes
          2. Merge using **"Create a merge commit"**
          3. üéâ Upstream sync complete!

          <details>
          <summary>üîß Resolution Details (click to expand)</summary>

          **Workflow steps completed:**
          1. ‚úÖ Started merge process
          2. ‚úÖ Claude edited files to resolve conflicts
          3. ‚úÖ Verified no conflict markers remain
          4. ‚úÖ Created merge commit with both parents
          5. ‚úÖ Pushed resolution to sync branch

          **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          </details>
          EOF
          )"
          else
            # Failure - determine which step failed
            gh pr comment ${PR_NUMBER} \
              --repo ${{ github.repository }} \
              --body "$(cat <<EOF
          ## ‚ùå Conflict Resolution Failed

          The automated resolution encountered an error.

          | Step | Status |
          |------|--------|
          | ‚úèÔ∏è Claude resolve | ${{ steps.claude-run.outcome }} |
          | üîç Verify no markers | ${{ steps.verify-resolution.outcome }} |
          | üß™ Sanity check | ${{ steps.sanity-check.outputs.has-issues == 'false' && 'success' || 'warning' }} |
          | üìù Create merge commit | ${{ steps.complete-merge.outcome }} |
          | üìå Push to sync branch | ${{ steps.push-resolution.outcome }} |

          > [!WARNING]
          > Manual intervention may be required. Check the workflow logs below.

          <details>
          <summary>üîß Troubleshooting (click to expand)</summary>

          **Common issues:**
          - Complex merge conflicts requiring human judgment
          - Leftover conflict markers in files
          - Test failures after resolution

          **Manual resolution:**
          \`\`\`bash
          git fetch origin
          git checkout <sync-branch>
          git merge origin/carto/main
          # Resolve conflicts manually
          make lint && make test-unit
          git push origin <sync-branch>
          \`\`\`

          </details>

          [View workflow logs ‚Üí](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )"
          fi

      - name: Add merge warning comment
        if: steps.push-resolution.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"

          echo "[Resolver] Adding merge warning comment to PR #${PR_NUMBER}"
          gh pr comment ${PR_NUMBER} --repo ${{ github.repository }} --body "> [!CAUTION]
          > ## ‚ö†Ô∏è Merge Method Reminder
          >
          > **Use \"Create a merge commit\"** ‚Äî Click the dropdown arrow next to merge button.
          >
          > ‚ùå Do NOT use \"Squash and merge\" or \"Rebase and merge\"
          >
          > _Squashing destroys upstream history and breaks future syncs (see PR #26)._"
          echo "[Resolver] ‚úÖ Merge warning comment added"
