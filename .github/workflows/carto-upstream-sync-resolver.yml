name: CARTO Upstream Sync - Conflict Resolver # do not change the name since is referenced in the ci-fixer workflow

# This workflow uses Claude Code to automatically resolve merge conflicts
# for upstream sync PRs, pushing resolution directly to the sync branch.
#
# Architecture (Single-PR, Deterministic):
#   1. Workflow starts merge (HARDCODED) - brings conflicts into working tree
#   2. Claude edits files ONLY - resolves conflict markers
#   3. Workflow completes merge commit (HARDCODED) - preserves both parents
#   4. Workflow pushes to sync branch (HARDCODED) - updates existing PR
#
# This ensures:
#   - Single PR workflow (no separate resolution PR)
#   - Merge commit always has both parents (upstream with main tag checkout + carto/main)
#   - Git operations are deterministic (not dependent on Claude's actions)
#
# Security features:
# - Only runs when triggered by authorized users (Cartofante, mateo-di)
# - Only runs on PRs labeled 'upstream-sync'
# - Only runs on upstream-sync/* branches (not main directly)
# - Only runs when conflicts are detected
# - Blocks external forks
# - Rate limited (max-turns: 250, job timeout: 90 mins)

on:
  pull_request:
    types: [opened, labeled, synchronize]
    branches:
      - carto/main
  workflow_dispatch:
    inputs:
      pr-number:
        description: "PR number to resolve conflicts for"
        required: true
        default: ""
      debug:
        description: "Enable debug logging"
        type: boolean
        default: false

# Prevent duplicate runs on the same PR
# IMPORTANT: Uses shared concurrency group with CI Fixer to prevent both running simultaneously
concurrency:
  group: upstream-sync-${{ github.event.pull_request.number || github.event.inputs.pr-number || github.run_id }}
  cancel-in-progress: false  # Wait for running workflow to finish (don't cancel)

permissions:
  contents: write      
  pull-requests: write

jobs:
  # Job 1: Security verification - MUST PASS before any other checks
  security-check:
    name: Security Verification
    runs-on: ubuntu-latest

    outputs:
      authorized: ${{ steps.verify.outputs.authorized }}

    steps:
      - name: Verify actor and PR source
        id: verify
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eu

          echo "::group::Security verification"

          # Security Check 1: Only allow specific authorized users
          ACTOR="${{ github.actor }}"
          ALLOWED_ACTORS="Cartofante mateo-di"

          # Check if actor is in allowed list (case-insensitive)
          ACTOR_LOWER="${ACTOR,,}"
          ALLOWED=false
          for allowed in ${ALLOWED_ACTORS}; do
            if [[ "${ACTOR_LOWER}" == "${allowed,,}" ]]; then
              ALLOWED=true
              break
            fi
          done

          if [[ "${ALLOWED}" == "false" ]]; then
            echo "[Security] ‚ùå Unauthorized actor: ${ACTOR}"
            echo "[Security] Allowed actors: ${ALLOWED_ACTORS}"
            echo "authorized=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "[Security] ‚úÖ Actor verified: ${ACTOR}"

          # Security Check 2: Verify branch flow (main ‚Üí carto/main)
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # Automatic trigger: validate PR directly from event
            HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"
            BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
            HEAD_REPO="${{ github.event.pull_request.head.repo.full_name }}"
            BASE_REPO="${{ github.repository }}"

            # Check fork - head repo must match base repo
            if [[ "${HEAD_REPO}" != "${BASE_REPO}" ]]; then
              echo "[Security] ‚ùå External fork detected: ${HEAD_REPO}"
              echo "[Security] Only internal branches allowed"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ PR source verified: internal branch"

            # Check branch flow - allow upstream-sync/* branches
            if [[ ! "${HEAD_BRANCH}" =~ ^upstream-sync/ ]] || [[ "${BASE_BRANCH}" != "carto/main" ]]; then
              echo "[Security] ‚ùå Invalid branch flow: ${HEAD_BRANCH} ‚Üí ${BASE_BRANCH}"
              echo "[Security] Required: upstream-sync/* ‚Üí carto/main"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ Branch flow verified: ${HEAD_BRANCH} ‚Üí carto/main"
          else
            # Manual trigger: fetch PR details via gh CLI
            PR_NUMBER="${{ github.event.inputs.pr-number }}"
            if [[ -z "${PR_NUMBER}" ]]; then
              echo "[Security] ‚ùå PR number required for manual dispatch"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "[Security] Manual dispatch for PR #${PR_NUMBER}"

            # Fetch PR details
            PR_JSON=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json headRefName,baseRefName,headRepositoryOwner,isCrossRepository)
            HEAD_BRANCH=$(echo "${PR_JSON}" | jq -r '.headRefName')
            BASE_BRANCH=$(echo "${PR_JSON}" | jq -r '.baseRefName')
            IS_FORK=$(echo "${PR_JSON}" | jq -r '.isCrossRepository')

            # Check fork - isCrossRepository is true for external forks
            if [[ "${IS_FORK}" == "true" ]]; then
              REPO_OWNER=$(echo "${PR_JSON}" | jq -r '.headRepositoryOwner.login')
              echo "[Security] ‚ùå External fork detected from: ${REPO_OWNER}"
              echo "[Security] Only internal branches allowed"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ PR source verified: internal branch"

            # Check branch flow - allow upstream-sync/* branches
            if [[ ! "${HEAD_BRANCH}" =~ ^upstream-sync/ ]] || [[ "${BASE_BRANCH}" != "carto/main" ]]; then
              echo "[Security] ‚ùå Invalid branch flow: ${HEAD_BRANCH} ‚Üí ${BASE_BRANCH}"
              echo "[Security] Required: upstream-sync/* ‚Üí carto/main"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ Branch flow verified: ${HEAD_BRANCH} ‚Üí carto/main"
          fi

          # All security checks passed
          echo "[Security] ‚úÖ All security checks passed"
          echo "authorized=true" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  # Job 2: Check if this PR is eligible for automated conflict resolution
  check-eligibility:
    name: Check PR Eligibility
    runs-on: ubuntu-latest
    needs: security-check
    if: needs.security-check.outputs.authorized == 'true'

    outputs:
      eligible: ${{ steps.check.outputs.eligible }}
      pr-number: ${{ steps.check.outputs.pr-number }}
      has-conflicts: ${{ steps.check.outputs.has-conflicts }}
      is-sync-pr: ${{ steps.check.outputs.is-sync-pr }}

    steps:
      - name: Check PR criteria
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eu

          # Get PR number based on trigger type
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
          else
            PR_NUMBER="${{ github.event.inputs.pr-number }}"
          fi

          echo "::group::Checking PR eligibility for conflict resolution"
          echo "[Resolver] Checking PR #${PR_NUMBER}"

          # Get PR details
          PR_JSON=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json labels,mergeable,headRefName,baseRefName)

          # Extract details
          echo "${PR_JSON}"
          BASE_BRANCH=$(echo "${PR_JSON}" | jq -r '.baseRefName')
          echo "BASE_BRANCH: ${BASE_BRANCH}"
          HEAD_BRANCH=$(echo "${PR_JSON}" | jq -r '.headRefName')
          echo "HEAD_BRANCH: ${HEAD_BRANCH}"
          MERGEABLE=$(echo "${PR_JSON}" | jq -r '.mergeable')
          echo "MERGEABLE: ${MERGEABLE}"
          LABELS=$(echo "${PR_JSON}" | jq -r '.labels[].name' | tr '\n' ' ')
          # Use jq for exact label matching (avoid substring matches)
          HAS_UPSTREAM_SYNC=$(echo "${PR_JSON}" | jq '[.labels[].name] | any(. == "upstream-sync")')
          echo "LABELS: ${LABELS}"

          echo "[Resolver] Base: ${BASE_BRANCH}, Head: ${HEAD_BRANCH}"
          echo "[Resolver] Mergeable status: ${MERGEABLE}"
          echo "[Resolver] Labels: ${LABELS}"

          # Check 1: Must be to carto/main
          if [[ "${BASE_BRANCH}" != "carto/main" ]]; then
            echo "[Resolver] ‚ùå Not targeting carto/main - skipping"
            echo "eligible=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check 2: Must have upstream-sync label (exact match)
          if [[ "${HAS_UPSTREAM_SYNC}" != "true" ]]; then
            echo "[Resolver] ‚ùå Missing 'upstream-sync' label - skipping"
            echo "is-sync-pr=false" >> $GITHUB_OUTPUT
            echo "eligible=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "is-sync-pr=true" >> $GITHUB_OUTPUT

          # Check 3: Must have conflicts (or manual trigger)
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual trigger: skip conflict check (user knows there are conflicts)
            echo "[Resolver] ‚ö†Ô∏è Manual trigger - skipping conflict check (status: ${MERGEABLE})"
            echo "[Resolver] Assuming conflicts exist (user manually triggered)"
            echo "has-conflicts=true" >> $GITHUB_OUTPUT
          elif [[ "${MERGEABLE}" == "CONFLICTING" ]]; then
            # Automatic trigger: conflicts detected
            echo "[Resolver] ‚ö†Ô∏è Conflicts detected (mergeable: ${MERGEABLE})"
            echo "has-conflicts=true" >> $GITHUB_OUTPUT
          elif [[ "${MERGEABLE}" == "UNKNOWN" ]]; then
            # Status not computed yet - treat as potential conflict
            echo "[Resolver] ‚ö†Ô∏è Mergeable status unknown - will attempt resolution"
            echo "has-conflicts=true" >> $GITHUB_OUTPUT
          else
            # Clean merge - no action needed
            echo "[Resolver] ‚úÖ No conflicts detected (mergeable: ${MERGEABLE})"
            echo "has-conflicts=false" >> $GITHUB_OUTPUT
            echo "eligible=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # All checks passed
          echo "[Resolver] ‚úÖ PR is eligible for conflict resolution"
          echo "eligible=true" >> $GITHUB_OUTPUT
          echo "pr-number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  # Job 3: Use Claude Code to resolve conflicts
  claude-resolve:
    name: Claude Code Conflict Resolution
    runs-on: ubuntu-latest
    timeout-minutes: 90  # Job timeout is the real limit (not max-turns)
    needs: [security-check, check-eligibility]
    if: needs.security-check.outputs.authorized == 'true' && needs.check-eligibility.outputs.eligible == 'true'

    steps:
      - name: Get PR branch info
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          # Get head and base refs based on trigger type
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            HEAD_REF="${{ github.event.pull_request.head.ref }}"
            BASE_REF="${{ github.event.pull_request.base.ref }}"
          else
            # For workflow_dispatch, fetch from PR
            PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"
            PR_JSON=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json headRefName,baseRefName)
            HEAD_REF=$(echo "${PR_JSON}" | jq -r '.headRefName')
            BASE_REF=$(echo "${PR_JSON}" | jq -r '.baseRefName')
          fi

          echo "head-ref=${HEAD_REF}" >> $GITHUB_OUTPUT
          echo "base-ref=${BASE_REF}" >> $GITHUB_OUTPUT
          echo "[Resolver] PR: ${HEAD_REF} ‚Üí ${BASE_REF}"
          echo "[Resolver] Will checkout sync branch (${HEAD_REF}) and merge ${BASE_REF} into it"
          echo "[Resolver] Resolution commits will be pushed directly to this PR's branch"

      # IMPORTANT: Checkout the sync branch (upstream-sync/vX.Y.Z) which has upstream commit history
      # Then merge BASE branch (carto/main) into it to bring CARTO customizations
      # Resolution commits are pushed directly to this branch, updating the existing PR
      - name: Checkout repository (sync branch - upstream with history)
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr-info.outputs.head-ref }}
          fetch-depth: 0
          token: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}

      - name: Configure git
        run: |
          git config --global user.name "Cartofante"
          git config --global user.email "cartofante@carto.com"

      - name: Check sync-required files status
        id: sync-check
        run: |
          echo "::group::Checking sync-required files"

          # Files that MUST stay in sync with upstream (accept upstream version)
          SYNC_FILES="schema.prisma"

          HEAD_REF="${{ steps.pr-info.outputs.head-ref }}"

          for FILE in $SYNC_FILES; do
            if [ -f "$FILE" ]; then
              # Compare with upstream version from this branch (which has upstream content)
              CURRENT_LINES=$(wc -l < $FILE | tr -d ' ')
              echo "[Resolver] $FILE: $CURRENT_LINES lines (current)"

              # Store sync-required files list for Claude
              echo "$FILE" >> /tmp/sync_required_files.txt
            fi
          done

          if [ -f /tmp/sync_required_files.txt ]; then
            echo "sync-files=$(cat /tmp/sync_required_files.txt | tr '\n' ' ')" >> $GITHUB_OUTPUT
          else
            echo "sync-files=" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

      - name: Start merge with carto/main (HARDCODED - creates conflicts)
        id: start-merge
        run: |
          echo "::group::Starting merge (WORKFLOW CONTROLLED)"
          echo "[Resolver] Strategy: Checkout ${HEAD_REF} (upstream) ‚Üí merge ${BASE_REF} (CARTO) into it"
          echo "[Resolver] This preserves upstream commit history in the PR"

          HEAD_REF="${{ steps.pr-info.outputs.head-ref }}"
          BASE_REF="${{ steps.pr-info.outputs.base-ref }}"

          # Fetch the base branch (carto/main with CARTO customizations)
          git fetch origin ${BASE_REF}:${BASE_REF}

          # Attempt merge of CARTO customizations into upstream
          # This is the REVERSE of the original PR direction, but preserves history
          if git merge ${BASE_REF} --no-commit --no-ff; then
            echo "[Resolver] ‚úÖ Clean merge - no conflicts found"
            echo "[Resolver] This PR should be mergeable without Claude's help"
            git merge --abort || true
            echo "has-conflicts=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "[Resolver] ‚ö†Ô∏è Conflicts detected - Claude will resolve file contents"

            # Save list of conflicted files for Claude
            CONFLICTS=$(git diff --name-only --diff-filter=U)
            echo "conflicts<<EOF" >> $GITHUB_OUTPUT
            echo "$CONFLICTS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            CONFLICT_COUNT=$(echo "$CONFLICTS" | wc -l)
            echo "conflict-count=${CONFLICT_COUNT}" >> $GITHUB_OUTPUT
            echo "has-conflicts=true" >> $GITHUB_OUTPUT

            echo "[Resolver] Conflicted files (${CONFLICT_COUNT}):"
            echo "$CONFLICTS"
          fi

          echo "::endgroup::"

      # =========================================================================
      # Auto-resolve build artifacts (accept upstream - CARTO doesn't customize these)
      # =========================================================================
      - name: Auto-resolve build artifacts (accept upstream)
        id: auto-resolve
        run: |
          echo "::group::Auto-resolving build artifacts"

          # Patterns for build artifacts and generated files
          # CARTO doesn't customize these - always accept upstream
          AUTO_RESOLVE_DIRS=(
            "litellm/proxy/_experimental/out/"
            "ui/litellm-dashboard/out/"
          )

          CONFLICTS=$(git diff --name-only --diff-filter=U 2>/dev/null || echo "")
          AUTO_RESOLVED=0

          for file in $CONFLICTS; do
            for dir in "${AUTO_RESOLVE_DIRS[@]}"; do
              if [[ "$file" == "$dir"* ]]; then
                echo "[Auto-resolve] Accepting upstream: $file"
                git checkout --theirs "$file" 2>/dev/null || true
                git add "$file" 2>/dev/null || true
                AUTO_RESOLVED=$((AUTO_RESOLVED + 1))
                break
              fi
            done
          done

          echo "[Auto-resolve] Resolved ${AUTO_RESOLVED} build artifact(s)"
          echo "auto-resolved=${AUTO_RESOLVED}" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Comment on PR - Starting
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          gh pr comment ${{ needs.check-eligibility.outputs.pr-number }} \
            --repo ${{ github.repository }} \
            --body "$(cat <<'EOF'
          ## ü§ñ Conflict Resolution Started

          **Status:** ‚è≥ In progress...

          Claude Code (Opus 4.5) is resolving merge conflicts in this PR.

          | Step | Status |
          |------|--------|
          | üîç Analyze conflicts | In progress |
          | ‚úèÔ∏è Resolve files | Pending |
          | üß™ Run tests | Pending |
          | üìå Push to PR | Pending |

          > [!NOTE]
          > This may take **30-90 minutes** for large PRs. Resolution commits will be pushed directly to this PR.

          <details>
          <summary>üìã Resolution Process (click to expand)</summary>

          1. üîç Analyzing conflicts in all files
          2. üìã Reading CARTO customization guidelines
          3. ‚öñÔ∏è Applying resolution priorities (CARTO first, then upstream)
          4. ‚úèÔ∏è Resolving conflicts file by file
          5. üß™ Running tests (lint, mypy, unit tests)
          6. üìå Pushing resolution directly to this PR

          </details>

          [View workflow run ‚Üí](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )"

      - name: Setup GCP credentials for Vertex AI
        run: |
          echo '${{ secrets.CI_RESOURCES_SERVICE_ACCOUNT }}' > /tmp/gcp-sa.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=/tmp/gcp-sa.json" >> $GITHUB_ENV

      # =========================================================================
      # CARTO PR Analysis - Identify files modified by CARTO org members
      # (Inlined because sync branches don't have .github/actions/)
      # =========================================================================
      - name: Analyze CARTO PRs and classify conflicted files
        id: carto-files
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          echo "::group::Analyzing CARTO PRs"

          CONFLICTS="${{ steps.start-merge.outputs.conflicts }}"
          OUTPUT_PATH="/tmp/carto-analysis"
          mkdir -p "${OUTPUT_PATH}"

          # Step 1: Fetch CartoDB org members
          echo "[Resolver] Fetching CartoDB org members..."
          ORG_MEMBERS=$(gh api "orgs/CartoDB/members" --paginate --jq '.[].login' 2>/dev/null | tr '\n' '|' | sed 's/|$//')

          if [ -z "$ORG_MEMBERS" ]; then
            echo "[Resolver] Warning: Could not fetch org members, using fallback"
            ORG_MEMBERS="Cartofante|mateo-di"
          fi

          MEMBER_COUNT=$(echo "$ORG_MEMBERS" | tr '|' '\n' | wc -l | tr -d ' ')
          echo "[Resolver] Found ${MEMBER_COUNT} org members"

          # Step 2: Fetch all merged PRs to carto/main
          echo "[Resolver] Fetching PRs merged to carto/main..."
          gh pr list \
            --repo ${{ github.repository }} \
            --base carto/main \
            --state merged \
            --limit 1000 \
            --json number,title,author,body,mergedAt,additions,deletions,files \
            > "${OUTPUT_PATH}/all_prs.json" 2>/dev/null || echo "[]" > "${OUTPUT_PATH}/all_prs.json"

          TOTAL_PRS=$(jq 'length' "${OUTPUT_PATH}/all_prs.json")
          echo "[Resolver] Found ${TOTAL_PRS} total PRs merged to carto/main"

          # Step 3: Filter to CARTO org member authors only
          # IMPORTANT: Exclude upstream-sync PRs (they sync upstream code, not CARTO customizations)
          # This prevents files touched by previous syncs from being incorrectly marked as "CARTO-modified"
          #
          # Exclusion criteria:
          # - Labels: upstream-sync (main sync PRs always have this)
          # - Titles: sync:, Upstream Sync:, fix: resolve conflicts, fix: resolve.*upstream,
          #           fix(ci): (CI fixer commits), merge: (merge commits)
          jq --arg pattern "$ORG_MEMBERS" '
            [.[] |
              select(.author.login | test("^(" + $pattern + ")$"; "i")) |
              # Exclude PRs with upstream-sync label (catches all main sync PRs)
              select(([.labels[].name] | any(. == "upstream-sync")) | not) |
              # Exclude PRs with sync/resolve/CI-fixer titles
              select(.title | test("^(sync:|upstream sync:|fix: resolve.*upstream|fix: resolve conflicts|fix\\(ci\\):|merge:)"; "i") | not) |
              # Also exclude PRs containing "Upstream Sync:" (catches emoji prefix like üîÑ)
              select(.title | test("Upstream Sync:"; "i") | not)
            ]
          ' "${OUTPUT_PATH}/all_prs.json" > "${OUTPUT_PATH}/carto_prs.json"

          CARTO_PRS=$(jq 'length' "${OUTPUT_PATH}/carto_prs.json")
          echo "[Resolver] Found ${CARTO_PRS} PRs by CARTO org members (excluding upstream-sync PRs)"

          # Step 4: Extract unique file paths from CARTO PRs
          jq -r '[.[] | .files[].path] | unique | .[]' "${OUTPUT_PATH}/carto_prs.json" > "${OUTPUT_PATH}/carto_files.txt"

          FILE_COUNT=$(wc -l < "${OUTPUT_PATH}/carto_files.txt" | tr -d ' ')
          echo "[Resolver] Found ${FILE_COUNT} unique CARTO-modified files"

          # Cleanup temp file
          rm -f "${OUTPUT_PATH}/all_prs.json"

          echo "::endgroup::"

          echo "::group::Classifying conflicted files"

          # Initialize output files
          > /tmp/carto_modified.txt
          > /tmp/upstream_only.txt

          # Classify each conflicted file
          for FILE in $CONFLICTS; do
            if grep -qxF "$FILE" "${OUTPUT_PATH}/carto_files.txt" 2>/dev/null; then
              echo "[Resolver] CARTO-MODIFIED: $FILE"
              echo "$FILE" >> /tmp/carto_modified.txt
            else
              echo "[Resolver] UPSTREAM-ONLY: $FILE"
              echo "$FILE" >> /tmp/upstream_only.txt
            fi
          done

          # Output results
          CARTO_FILES=$(cat /tmp/carto_modified.txt | grep -v '^$' || echo "")
          UPSTREAM_FILES=$(cat /tmp/upstream_only.txt | grep -v '^$' || echo "")

          CARTO_COUNT=$(echo "$CARTO_FILES" | grep -c . || echo 0)
          UPSTREAM_COUNT=$(echo "$UPSTREAM_FILES" | grep -c . || echo 0)

          echo ""
          echo "[Resolver] Classification Summary:"
          echo "  CARTO-modified files: ${CARTO_COUNT}"
          echo "  Upstream-only files: ${UPSTREAM_COUNT}"

          echo "carto-files<<EOF" >> $GITHUB_OUTPUT
          echo "$CARTO_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "upstream-files<<EOF" >> $GITHUB_OUTPUT
          echo "$UPSTREAM_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Build CARTO context from PR analysis
        id: carto-context
        run: |
          echo "::group::Building CARTO context for Claude"

          CARTO_FILES="${{ steps.carto-files.outputs.carto-files }}"

          if [ -f /tmp/carto-analysis/carto_prs.json ]; then
            echo "[Resolver] Building context from PR analysis"

            TOTAL_PRS=$(jq 'length' /tmp/carto-analysis/carto_prs.json)
            echo "[Resolver] Found ${TOTAL_PRS} CARTO PRs"

            # Build context for each CARTO-modified conflicted file
            > /tmp/carto_pr_context.md

            for FILE in $CARTO_FILES; do
              FILE_PRS=$(jq -r --arg f "$FILE" '
                [.[] | select(.files | map(.path) | any(. == $f))] |
                .[] | "- PR #\(.number): \(.title) (@\(.author.login))"
              ' /tmp/carto-analysis/carto_prs.json)

              if [ -n "$FILE_PRS" ]; then
                echo "### \`$FILE\`" >> /tmp/carto_pr_context.md
                echo "$FILE_PRS" >> /tmp/carto_pr_context.md
                echo "" >> /tmp/carto_pr_context.md
              fi
            done

            # Create PR summary table
            jq -r '
              sort_by(.mergedAt) | reverse | .[0:50] |
              .[] | "| #\(.number) | \(.title | .[0:40])... | @\(.author.login) | \(.files | length) files |"
            ' /tmp/carto-analysis/carto_prs.json > /tmp/carto_pr_table.md

            echo "total-prs=${TOTAL_PRS}" >> $GITHUB_OUTPUT
          else
            echo "[Resolver] No PR artifact - context will be minimal"
            echo "No cached PR context available" > /tmp/carto_pr_context.md
            echo "No cached PR table available" > /tmp/carto_pr_table.md
            echo "total-prs=0" >> $GITHUB_OUTPUT
          fi

          echo "[Resolver] Context written to /tmp/carto_pr_context.md"
          echo "context-file=/tmp/carto_pr_context.md" >> $GITHUB_OUTPUT
          echo "table-file=/tmp/carto_pr_table.md" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Fetch PR comments for context
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          echo "::group::Fetching PR comments for previous resolution context"

          PR_NUMBER="${{ github.event.pull_request.number || github.event.inputs.pr-number }}"

          # Fetch all PR comments (includes previous resolution attempts, human feedback)
          gh pr view ${PR_NUMBER} \
            --repo ${{ github.repository }} \
            --json comments \
            --jq '.comments[] | "---\n**\(.author.login)** at \(.createdAt):\n\(.body)\n"' \
            > /tmp/pr_comments.md 2>/dev/null || echo "No comments found" > /tmp/pr_comments.md

          COMMENT_COUNT=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json comments --jq '.comments | length' 2>/dev/null || echo "0")
          echo "[Resolver] Found ${COMMENT_COUNT} PR comments for context"

          echo "::endgroup::"

      - name: Run Claude Code for conflict resolution (FILE EDITS ONLY)
        id: claude-run
        uses: anthropics/claude-code-action@v1
        with:
          use_vertex: "true"
          github_token: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
          show_full_output: true
          claude_args: "--model claude-opus-4-5@20251101 --max-turns 250 --allowedTools Read,Write,Edit,Bash,Grep,Glob ${{ github.event.inputs.debug == 'true' && '--debug' || '' }}"
          prompt: |
            # Conflict Resolution Task - CARTO-FIRST STRATEGY

            ## ‚ö†Ô∏è CRITICAL: CARTO CUSTOMIZATIONS ARE MANDATORY TO PRESERVE

            **Key Principle:** CARTO customizations made by CartoDB organization members are **INTENTIONAL and MUST be preserved**. Upstream changes should be merged **AROUND** CARTO code, not replacing it.

            The git merge has ALREADY been started by the workflow.
            You are in a merge conflict state with ${{ steps.start-merge.outputs.conflict-count }} conflicted files.

            **DO NOT RUN THESE COMMANDS - THE WORKFLOW WILL HANDLE THEM:**
            - ‚ùå `git commit` - Workflow does this AFTER you finish
            - ‚ùå `git checkout -b` - Workflow does this AFTER you finish
            - ‚ùå `git push` - Workflow does this AFTER you finish
            - ‚ùå `gh pr create` - Workflow does this AFTER you finish

            **YOUR ONLY JOB:**
            1. Read conflicted files
            2. Edit files to remove conflict markers (PRESERVING CARTO CODE)
            3. Run tests and fix issues
            4. Say "RESOLUTION COMPLETE" when done

            ## Pre-Analysis: CARTO vs Upstream Files

            The workflow has analyzed which files have CARTO commits:

            **üîí CARTO-MODIFIED FILES (MUST KEEP CARTO VERSION):**
            ```
            ${{ steps.carto-files.outputs.carto-files }}
            ```

            **üì• UPSTREAM-ONLY FILES (Accept upstream):**
            ```
            ${{ steps.carto-files.outputs.upstream-files }}
            ```

            ## All Conflicted Files (${{ steps.start-merge.outputs.conflict-count }} files)

            ```
            ${{ steps.start-merge.outputs.conflicts }}
            ```

            ## Step 0: Check Previous Resolution Attempts

            **IMPORTANT:** Read PR comments first for context on previous attempts:
            ```bash
            cat /tmp/pr_comments.md
            ```

            This shows:
            - Previous Claude resolution attempts and what was tried
            - Human feedback or guidance
            - Issues that have already been addressed

            **If a previous resolution attempt exists, learn from it - don't repeat failed approaches.**

            ## Step 1: Read CARTO Guidelines

            ```bash
            cat CARTO_CLAUDE.md
            ```

            ## Step 2: Resolution Rules (CARTO-FIRST PRIORITY)

            **Conflict markers look like this:**
            ```
            <<<<<<< HEAD
            [upstream code from main branch]
            =======
            [CARTO code from carto/main branch]
            >>>>>>> carto/main
            ```

            ## ‚ö†Ô∏è CRITICAL: SYNC-REQUIRED FILES (ALWAYS ACCEPT UPSTREAM)

            These files MUST track upstream even if CARTO has commits. Accept the upstream (HEAD) version:

            | File | Reason |
            |------|--------|
            | `schema.prisma` | Database schema MUST match LiteLLM code expectations |
            | `litellm/proxy/schema.prisma` | Upstream Prisma schema |

            **For schema.prisma specifically:**
            - ALWAYS accept the upstream (HEAD) version - it has more tables
            - Missing tables cause runtime errors like: `'Prisma' object has no attribute 'litellm_agentstable'`
            - If CARTO added unique tables, add them AFTER accepting upstream, but this is rare

            **Resolution priorities (with SYNC-REQUIRED EXCEPTION):**

            | Priority | File Pattern | Resolution | Reason |
            |----------|--------------|------------|--------|
            | **0** | `schema.prisma` | **ACCEPT UPSTREAM (HEAD)** | Database schema must match code |
            | 1 | Files in CARTO-MODIFIED list above | **KEEP carto/main** | CartoDB org members made intentional changes |
            | 2 | `carto_*.yaml`, `carto-*.yml` | **KEEP carto/main** | CARTO workflows |
            | 3 | `CARTO_*.md` | **KEEP carto/main** | CARTO docs |
            | 4 | Files in UPSTREAM-ONLY list above | Accept HEAD (upstream) | No CARTO changes |
            | 5 | `pyproject.toml` | Merge carefully | Upstream version + CARTO deps |
            | 6 | `Dockerfile`, `Makefile` | Merge carefully | Keep `# CARTO:` sections |

            ## CARTO Customizations for Conflicted Files

            The workflow has analyzed ${{ steps.carto-context.outputs.total-prs }} merged PRs to carto/main.

            **Read these files for CARTO context:**
            - `/tmp/carto_pr_context.md` - Detailed context for each CARTO-modified conflicted file
            - `/tmp/carto_pr_table.md` - Summary table of all CARTO PRs

            ```bash
            # Read CARTO context for conflicted files
            cat /tmp/carto_pr_context.md

            # Read summary of all CARTO PRs (if needed)
            cat /tmp/carto_pr_table.md
            ```

            **To get full details about a specific PR (description, discussion, files):**
            ```bash
            gh pr view <PR_NUMBER> --repo ${{ github.repository }}
            ```

            ## Step 3: Resolve Each File (CARTO-FIRST)

            For EACH conflicted file:

            ### If file is in CARTO-MODIFIED list:
            1. **Read** the file
            2. **KEEP the CARTO version** (after `=======`, before `>>>>>>> carto/main`)
            3. **ALSO check if upstream added NEW code** that doesn't conflict with CARTO fix
            4. **Merge BOTH** if possible: Keep CARTO fix + add non-conflicting upstream additions

            ### If file is in UPSTREAM-ONLY list:
            1. **Read** the file
            2. **Accept upstream version** (after `<<<<<<< HEAD`, before `=======`)
            3. Remove conflict markers

            ### Correct Merge Example (keeping BOTH):
            ```python
            # CORRECT: Keep CARTO fix, add upstream feature
            def process(self, data):
                # CARTO fix: Handle null metadata (PRESERVED)
                if data.get('metadata') is None:
                    data['metadata'] = {}
                # New upstream feature (ADDED)
                if data.get('new_flag'):
                    self.handle_new_flag(data)
                return self.transform(data)
            ```

            ### WRONG Merge (losing CARTO code):
            ```python
            # WRONG: Lost CARTO fix, only kept upstream
            def process(self, data):
                # CARTO fix is GONE - this is WRONG!
                if data.get('new_flag'):
                    self.handle_new_flag(data)
                return self.transform(data)
            ```

            ## Step 4: Run Tests

            After resolving ALL files:

            ```bash
            # Verify no conflict markers remain
            grep -r "^<<<<<<< \|^=======\|^>>>>>>>" --include="*.py" litellm/ tests/ || echo "‚úÖ No conflict markers found"

            # Install deps and run tests
            make install-dev
            make lint
            make lint-mypy
            ```

            Fix any errors that occur.

            ## Step 5: Confirm Completion

            When ALL files are resolved and tests pass, say:

            **"RESOLUTION COMPLETE"**

            The workflow will then:
            1. Stage all changes (`git add -A`)
            2. Create merge commit (`git commit`)
            3. Push directly to the sync branch (this PR will update automatically!)

            ---

            **REMEMBER: CARTO code is INTENTIONAL. Preserve it. Begin resolving conflicts now!**

        env:
          ANTHROPIC_VERTEX_PROJECT_ID: carto-ci-resources
          CLOUD_ML_REGION: global
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
          GITHUB_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}

      - name: Cleanup GCP credentials
        if: always()
        run: rm -f /tmp/gcp-sa.json

      # =========================================================================
      # CARTO Patch Verification - Dynamically verify CARTO code is preserved
      # =========================================================================
      - name: Verify CARTO patches preserved (dynamic check)
        id: verify-carto-patches
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          echo "::group::Verifying CARTO patches are preserved"

          # Get list of CARTO-modified files from earlier step
          CARTO_FILES="${{ steps.carto-files.outputs.carto-files }}"

          if [ -z "$CARTO_FILES" ]; then
            echo "[Verify] No CARTO-modified files were identified - skipping verification"
            echo "verified=true" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
          fi

          echo "[Verify] Checking CARTO patches in $(echo "$CARTO_FILES" | wc -l | tr -d ' ') files..."

          MISSING_PATCHES=0
          WARNINGS=""

          # For each CARTO-modified file, verify it still has CARTO-specific code
          for FILE in $CARTO_FILES; do
            if [ ! -f "$FILE" ]; then
              echo "::warning::CARTO file missing: $FILE"
              WARNINGS="${WARNINGS}\n- ‚ö†Ô∏è File missing: $FILE"
              continue
            fi

            # Check for CARTO markers (comments that indicate CARTO customizations)
            # Look for: # CARTO:, # PATCH:, _patch_, or commits from CARTO PRs
            if grep -qE "# CARTO:|# PATCH:|_patch_|CARTO.*fix|Redis.*session" "$FILE" 2>/dev/null; then
              echo "  ‚úÖ $FILE - CARTO markers found"
            else
              # No explicit markers - check if file content from carto/main is preserved
              # by comparing unique lines from carto/main with the resolved file

              # Get the file from carto/main to compare
              CARTO_CONTENT=$(git show origin/carto/main:"$FILE" 2>/dev/null | head -100 || echo "")
              CURRENT_CONTENT=$(head -100 "$FILE" 2>/dev/null || echo "")

              if [ "$CARTO_CONTENT" != "$CURRENT_CONTENT" ]; then
                # File was modified - check if CARTO changes are still there
                # by looking for unique lines from carto/main version
                CARTO_UNIQUE=$(git show origin/carto/main:"$FILE" 2>/dev/null | grep -vxFf <(cat "$FILE") | head -5 || echo "")

                if [ -n "$CARTO_UNIQUE" ]; then
                  echo "::warning::CARTO code may be missing from: $FILE"
                  WARNINGS="${WARNINGS}\n- ‚ö†Ô∏è CARTO code may be missing: $FILE"
                  MISSING_PATCHES=$((MISSING_PATCHES + 1))
                else
                  echo "  ‚úÖ $FILE - CARTO changes preserved"
                fi
              else
                echo "  ‚úÖ $FILE - matches carto/main"
              fi
            fi
          done

          if [ $MISSING_PATCHES -gt 0 ]; then
            echo ""
            echo "::warning::$MISSING_PATCHES files may have lost CARTO patches!"
            echo "Review these files manually before merging."
            echo "verified=partial" >> $GITHUB_OUTPUT
            echo "warnings<<EOF" >> $GITHUB_OUTPUT
            echo -e "$WARNINGS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo ""
            echo "‚úÖ All CARTO patches verified"
            echo "verified=true" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

      # =========================================================================
      # File Rename Detection - Detect upstream renames affecting CARTO patches
      # =========================================================================
      - name: Detect upstream file renames affecting CARTO patches
        id: detect-renames
        run: |
          echo "::group::Detecting file renames that may affect CARTO patches"

          # Get CARTO-modified files
          CARTO_FILES="${{ steps.carto-files.outputs.carto-files }}"

          if [ -z "$CARTO_FILES" ]; then
            echo "[Renames] No CARTO files to check"
            echo "has-problematic-renames=false" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
          fi

          # Check for renames between carto/main and HEAD (the merged result)
          RENAMES=$(git diff --name-status --find-renames=50% origin/carto/main HEAD -- litellm/ 2>/dev/null | grep "^R" || echo "")

          if [ -z "$RENAMES" ]; then
            echo "[Renames] No file renames detected"
            echo "has-problematic-renames=false" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
          fi

          echo "[Renames] Found renames:"
          echo "$RENAMES"

          PROBLEMATIC=""
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            OLD_PATH=$(echo "$line" | awk '{print $2}')
            NEW_PATH=$(echo "$line" | awk '{print $3}')

            # Check if the old path was a CARTO-modified file
            if echo "$CARTO_FILES" | grep -q "^${OLD_PATH}$"; then
              echo "::warning::CARTO patch in renamed file: $OLD_PATH ‚Üí $NEW_PATH"
              PROBLEMATIC="${PROBLEMATIC}\n- \`${OLD_PATH}\` ‚Üí \`${NEW_PATH}\`"
            fi
          done <<< "$RENAMES"

          if [ -n "$PROBLEMATIC" ]; then
            echo "has-problematic-renames=true" >> $GITHUB_OUTPUT
            echo "renamed-files<<EOF" >> $GITHUB_OUTPUT
            echo -e "$PROBLEMATIC" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo ""
            echo "::warning::Some CARTO-patched files were renamed by upstream!"
            echo "Verify the patches were applied to the new file locations."
          else
            echo "[Renames] No CARTO-patched files were renamed"
            echo "has-problematic-renames=false" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

      # ============================================================
      # POST-CLAUDE: Complete merge, create branch, push, create PR
      # These steps are HARDCODED to ensure correct git operations
      # ============================================================

      - name: Verify no conflict markers remain
        id: verify-resolution
        run: |
          echo "::group::Verifying conflict resolution"

          # Check for conflict markers in source files
          # Use specific patterns to avoid false positives (markdown dividers like ====)
          # Real conflict markers: <<<<<<< HEAD, =======, >>>>>>> branch

          FOUND_MARKERS=$(grep -rE "^(<{7}|>{7}|={7})[[:space:]]" \
            --include="*.py" \
            --include="*.yaml" --include="*.yml" \
            --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" \
            --include="*.toml" \
            --include="*.prisma" \
            --include="*.json" \
            . 2>/dev/null \
            | grep -v ".git" \
            | grep -v "_experimental/out/" \
            | grep -v "node_modules/" \
            || echo "")

          if [ -n "$FOUND_MARKERS" ]; then
            echo "‚ùå ERROR: Conflict markers still present!"
            echo "$FOUND_MARKERS"
            echo "Claude did not fully resolve all conflicts."
            echo "resolved=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "‚úÖ No conflict markers found"
          echo "resolved=true" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Complete merge commit (HARDCODED - creates merge with both parents)
        id: complete-merge
        if: steps.verify-resolution.outputs.resolved == 'true'
        run: |
          echo "::group::Completing merge commit (WORKFLOW CONTROLLED)"

          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"

          # Stage all resolved files
          git add -A

          # Complete the merge - this creates a MERGE COMMIT with BOTH parents:
          # - Parent 1: main (upstream with main tag checkout)
          # - Parent 2: carto/main (CARTO customizations)
          git commit -m "fix: resolve upstream sync conflicts for PR #${PR_NUMBER}

          Conflicts resolved by Claude Code following CARTO priority rules.

          Resolution strategy:
          - Preserved CARTO customizations (workflows, docs, infrastructure)
          - Accepted upstream improvements (core litellm, tests, dependencies)
          - Manually merged mixed files (Dockerfile, Makefile)

          This is a MERGE COMMIT with both main and carto/main as parents,
          preserving full git history from upstream.

          Resolves: #${PR_NUMBER}"

          # Verify we created a merge commit (should have 2 parents)
          PARENT_COUNT=$(git cat-file -p HEAD | grep "^parent" | wc -l)
          if [ "$PARENT_COUNT" -lt 2 ]; then
            echo "‚ö†Ô∏è WARNING: Commit has only ${PARENT_COUNT} parent(s), expected 2 for merge commit"
          else
            echo "‚úÖ Merge commit created with ${PARENT_COUNT} parents"
          fi

          echo "merge-commit=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Push resolution to sync branch (HARDCODED - updates existing PR)
        id: push-resolution
        if: steps.verify-resolution.outputs.resolved == 'true'
        run: |
          echo "::group::Pushing resolution to sync branch (WORKFLOW CONTROLLED)"

          HEAD_REF="${{ steps.pr-info.outputs.head-ref }}"
          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"

          # Push directly to the sync branch - this updates the existing PR!
          # No need to create a new branch or PR
          echo "[Resolver] Pushing merge commit to ${HEAD_REF}..."
          git push origin HEAD:${HEAD_REF}

          echo "‚úÖ Pushed resolution to: ${HEAD_REF}"
          echo "‚úÖ PR #${PR_NUMBER} will automatically update with the resolved changes"
          echo "branch-name=${HEAD_REF}" >> $GITHUB_OUTPUT
          echo "::endgroup::"
    
      - name: Check if more conflicts remain after push
        id: check-remaining
        if: steps.push-resolution.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          echo "::group::Checking if PR still has conflicts"

          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"

          # Wait for GitHub to compute mergeable status
          sleep 10

          MERGEABLE=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json mergeable --jq '.mergeable')
          echo "[Resolver] PR mergeable status: ${MERGEABLE}"

          if [[ "${MERGEABLE}" == "CONFLICTING" ]]; then
            echo "[Resolver] PR still has conflicts - retriggering resolver"
            gh workflow run carto-upstream-sync-resolver.yml \
              --repo ${{ github.repository }} \
              -f pr-number=${PR_NUMBER}
            echo "retriggered=true" >> $GITHUB_OUTPUT
          else
            echo "[Resolver] PR is clean - no retrigger needed"
            echo "retriggered=false" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"
          
      - name: Summary
        if: always()
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          echo "::group::Workflow Execution Summary"
          echo "[Resolver] Conflict resolution workflow completed"
          echo "[Resolver] Claude edited files, workflow pushed to existing PR"
          echo "::endgroup::"

          # Get PR URL for the summary
          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"
          PR_URL=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json url --jq '.url')

          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ü§ñ Conflict Resolution Summary

          **PR Updated:** ${PR_URL}
          **Sync Branch:** ${{ steps.push-resolution.outputs.branch-name || 'N/A' }}

          ### Workflow Architecture (Single-PR, Deterministic)

          | Step | Handled By | Status |
          |------|------------|--------|
          | Start merge | Workflow (hardcoded) | ‚úÖ |
          | Edit conflicted files | Claude Code | ${{ steps.claude-run.outcome == 'success' && '‚úÖ' || '‚ùå' }} |
          | Verify no markers | Workflow (hardcoded) | ${{ steps.verify-resolution.outcome == 'success' && '‚úÖ' || '‚ùå' }} |
          | Verify CARTO patches | Workflow (dynamic) | ${{ steps.verify-carto-patches.outputs.verified == 'true' && '‚úÖ' || (steps.verify-carto-patches.outputs.verified == 'partial' && '‚ö†Ô∏è' || '‚ùå') }} |
          | Detect file renames | Workflow (hardcoded) | ${{ steps.detect-renames.outputs.has-problematic-renames == 'true' && '‚ö†Ô∏è' || '‚úÖ' }} |
          | Create merge commit | Workflow (hardcoded) | ${{ steps.complete-merge.outcome == 'success' && '‚úÖ' || '‚ùå' }} |
          | Push to sync branch | Workflow (hardcoded) | ${{ steps.push-resolution.outcome == 'success' && '‚úÖ' || '‚ùå' }} |

          ### Key Improvements

          1. **Single-PR workflow** - No separate resolution PR, changes pushed directly to sync branch
          2. **Deterministic** - Git operations are hardcoded in workflow, not in Claude's prompt
          3. **Merge commit preserved** - Both parents (upstream + carto/main) for proper history

          **Merge commit:** \`${{ steps.complete-merge.outputs.merge-commit || 'N/A' }}\`
          EOF

      - name: Comment on PR - Completion
        if: always()
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"
          PUSH_SUCCESS="${{ steps.push-resolution.outcome }}"

          if [ "${PUSH_SUCCESS}" == "success" ]; then
            # Success - resolution pushed to sync branch
            gh pr comment ${PR_NUMBER} \
              --repo ${{ github.repository }} \
              --body "$(cat <<EOF
          ## ‚úÖ Conflict Resolution Complete

          All conflicts resolved and pushed to this PR.

          | Step | Status |
          |------|--------|
          | üîç Analyze conflicts | ‚úÖ Complete |
          | ‚úèÔ∏è Resolve files | ‚úÖ Complete |
          | üß™ Verify resolution | ‚úÖ Complete |
          | üìå Push to PR | ‚úÖ Complete |

          > [!IMPORTANT]
          > **Ready to merge!** Use **"Create a merge commit"** ‚Äî do NOT squash or rebase.

          ### Next Steps

          1. Review the resolved changes
          2. Merge using **"Create a merge commit"**
          3. üéâ Upstream sync complete!

          <details>
          <summary>üîß Resolution Details (click to expand)</summary>

          **Workflow steps completed:**
          1. ‚úÖ Started merge process
          2. ‚úÖ Claude edited files to resolve conflicts
          3. ‚úÖ Verified no conflict markers remain
          4. ‚úÖ Created merge commit with both parents
          5. ‚úÖ Pushed resolution to sync branch

          **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          </details>
          EOF
          )"
          else
            # Failure - determine which step failed
            gh pr comment ${PR_NUMBER} \
              --repo ${{ github.repository }} \
              --body "$(cat <<EOF
          ## ‚ùå Conflict Resolution Failed

          The automated resolution encountered an error.

          | Step | Status |
          |------|--------|
          | ‚úèÔ∏è Claude file edits | ${{ steps.claude-run.outcome }} |
          | üîç Verify no markers | ${{ steps.verify-resolution.outcome }} |
          | üîí Verify CARTO patches | ${{ steps.verify-carto-patches.outputs.verified == 'true' && 'success' || (steps.verify-carto-patches.outputs.verified == 'partial' && 'warning' || 'failed') }} |
          | üîÑ Detect file renames | ${{ steps.detect-renames.outputs.has-problematic-renames == 'true' && 'warning' || 'success' }} |
          | üìù Create merge commit | ${{ steps.complete-merge.outcome }} |
          | üìå Push to sync branch | ${{ steps.push-resolution.outcome }} |

          > [!WARNING]
          > Manual intervention may be required. Check the workflow logs below.

          <details>
          <summary>üîß Troubleshooting (click to expand)</summary>

          **Common issues:**
          - Complex merge conflicts requiring human judgment
          - Leftover conflict markers in files
          - Test failures after resolution

          **Manual resolution:**
          \`\`\`bash
          git fetch origin
          git checkout <sync-branch>
          git merge origin/carto/main
          # Resolve conflicts manually
          make lint && make test-unit
          git push origin <sync-branch>
          \`\`\`

          </details>

          [View workflow logs ‚Üí](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )"
          fi

      - name: Add merge warning comment
        if: steps.push-resolution.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"

          echo "[Resolver] Adding merge warning comment to PR #${PR_NUMBER}"
          gh pr comment ${PR_NUMBER} --repo ${{ github.repository }} --body "> [!CAUTION]
          > ## ‚ö†Ô∏è Merge Method Reminder
          >
          > **Use \"Create a merge commit\"** ‚Äî Click the dropdown arrow next to merge button.
          >
          > ‚ùå Do NOT use \"Squash and merge\" or \"Rebase and merge\"
          >
          > _Squashing destroys upstream history and breaks future syncs (see PR #26)._"
          echo "[Resolver] ‚úÖ Merge warning comment added"
