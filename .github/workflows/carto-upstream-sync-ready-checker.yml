name: CARTO - Upstream Sync Ready Checker

# Watches CI workflow completions and adds "sync-ready" label when PR is fully ready
# This label then triggers the n8n notifier workflow
# Also posts Step 3/4 Slack notifications for test status

on:
  workflow_run:
    workflows:
      - "LiteLLM Mock Tests (folder - tests/test_litellm)"
      - "CARTO - Deploy Docker Image (CI)"
      - "LiteLLM Linting"
    types:
      - completed
    branches:
      - 'upstream-sync/**'

permissions:
  contents: read
  pull-requests: write  # Need write to add labels

env:
  SLACK_CHANNEL_LITELLM: "C0A11FKJHDK"  # litellm-fork changelog
  DOCS_URL: "https://cartodb.getoutline.com/doc/ci-litellm-fork-pMyvwMTU3l"

jobs:
  check-and-label:
    name: Check if PR is ready
    runs-on: ubuntu-latest
    # Only run on successful CI completions
    if: github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Check PR readiness and add label
        id: check-and-label
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eu

          BRANCH="${{ github.event.workflow_run.head_branch }}"
          echo "::group::Checking if PR from ${BRANCH} is ready for sync-ready label"

          # Find PR for this branch
          PR_JSON=$(gh pr list \
            --repo ${{ github.repository }} \
            --head "${BRANCH}" \
            --base "carto/main" \
            --json number,mergeable,labels,url,title \
            --jq '.[0]')

          if [[ -z "${PR_JSON}" || "${PR_JSON}" == "null" ]]; then
            echo "[Ready Checker] No PR found for branch ${BRANCH}"
            echo "::endgroup::"
            exit 0
          fi

          PR_NUMBER=$(echo "${PR_JSON}" | jq -r '.number')
          MERGEABLE=$(echo "${PR_JSON}" | jq -r '.mergeable')
          PR_URL=$(echo "${PR_JSON}" | jq -r '.url')
          PR_TITLE=$(echo "${PR_JSON}" | jq -r '.title')
          LABELS=$(echo "${PR_JSON}" | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')

          echo "[Ready Checker] PR #${PR_NUMBER}: ${PR_TITLE}"
          echo "[Ready Checker] Mergeable: ${MERGEABLE}"
          echo "[Ready Checker] Labels: ${LABELS}"

          # Check 1: Must have upstream-sync label
          if [[ ! "${LABELS}" =~ "upstream-sync" ]]; then
            echo "[Ready Checker] ‚ùå Missing upstream-sync label - not an upstream sync PR"
            echo "::endgroup::"
            exit 0
          fi

          # Check 2: Must NOT already have sync-ready label (avoid duplicate work)
          if [[ "${LABELS}" =~ "sync-ready" ]]; then
            echo "[Ready Checker] ‚úÖ Already has sync-ready label - nothing to do"
            echo "::endgroup::"
            exit 0
          fi

          # Check 3: Must be mergeable (no conflicts)
          if [[ "${MERGEABLE}" != "MERGEABLE" ]]; then
            echo "[Ready Checker] ‚ùå PR not mergeable (status: ${MERGEABLE}) - waiting for conflict resolution"
            echo "::endgroup::"
            exit 0
          fi

          # Check 4: All required checks must pass (no FAILURE or PENDING)
          echo "[Ready Checker] Checking all CI status..."

          CHECKS_JSON=$(gh pr checks ${PR_NUMBER} \
            --repo ${{ github.repository }} \
            --json name,state)

          FAILED_COUNT=$(echo "${CHECKS_JSON}" | jq '[.[] | select(.state == "FAILURE")] | length')
          PENDING_COUNT=$(echo "${CHECKS_JSON}" | jq '[.[] | select(.state == "PENDING")] | length')
          SUCCESS_COUNT=$(echo "${CHECKS_JSON}" | jq '[.[] | select(.state == "SUCCESS")] | length')

          echo "[Ready Checker] Checks: ${SUCCESS_COUNT} success, ${PENDING_COUNT} pending, ${FAILED_COUNT} failed"

          if [[ "${FAILED_COUNT}" -gt 0 ]]; then
            echo "[Ready Checker] ‚ùå ${FAILED_COUNT} checks failed - waiting for CI fixer"
            echo "${CHECKS_JSON}" | jq -r '.[] | select(.state == "FAILURE") | "  - \(.name): FAILED"'
            echo "::endgroup::"
            exit 0
          fi

          if [[ "${PENDING_COUNT}" -gt 0 ]]; then
            echo "[Ready Checker] ‚è≥ ${PENDING_COUNT} checks still pending - waiting..."
            echo "${CHECKS_JSON}" | jq -r '.[] | select(.state == "PENDING") | "  - \(.name): PENDING"'
            echo "::endgroup::"
            exit 0
          fi

          # All conditions met! Add the sync-ready label
          echo "[Ready Checker] ‚úÖ All conditions met! Adding sync-ready label..."

          gh pr edit ${PR_NUMBER} \
            --repo ${{ github.repository }} \
            --add-label "sync-ready"

          echo "[Ready Checker] üéâ Added sync-ready label to PR #${PR_NUMBER}"
          echo "::notice title=PR Ready::${PR_URL} is now ready for merge and n8n notification"

          # Export for Slack notification
          echo "pr-ready=true" >> $GITHUB_OUTPUT
          echo "pr-number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "pr-url=${PR_URL}" >> $GITHUB_OUTPUT
          echo "pr-title=${PR_TITLE}" >> $GITHUB_OUTPUT

          # Extract version from branch
          VERSION=$(echo "${BRANCH}" | sed 's|upstream-sync/||')
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Notify Slack - Tests Passed
        if: steps.check-and-label.outputs.pr-ready == 'true'
        env:
          PR_NUMBER: ${{ steps.check-and-label.outputs.pr-number }}
          PR_URL: ${{ steps.check-and-label.outputs.pr-url }}
          VERSION: ${{ steps.check-and-label.outputs.version }}
        run: |
          set -eu

          echo "::group::Posting Step 4 notification to Slack"

          WORKFLOW_URL="${{ github.event.workflow_run.html_url }}"

          # Build Block Kit payload for tests passed
          cat > /tmp/slack_payload.json << EOF
          {
            "channel": "${SLACK_CHANNEL_LITELLM}",
            "text": "‚úÖ LiteLLM Upstream Sync: Tests Passed",
            "attachments": [
              {
                "color": "#36a64f",
                "blocks": [
                  {
                    "type": "header",
                    "text": {
                      "type": "plain_text",
                      "text": "‚úÖ LiteLLM Upstream Sync",
                      "emoji": true
                    }
                  },
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": "*Step 4 of 4: Tests Passed* :white_check_mark:\n\n‚Ä¢ All CI checks completed successfully\n‚Ä¢ Version: \`${VERSION}\`\n‚Ä¢ PR ready for review and merge"
                    }
                  },
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": "*Action Required*\n‚Ä¢ Review the PR changes\n‚Ä¢ Merge to deploy the update"
                    }
                  },
                  {
                    "type": "context",
                    "elements": [
                      {
                        "type": "mrkdwn",
                        "text": ":book: <${DOCS_URL}|LiteLLM Fork CI Docs>"
                      }
                    ]
                  },
                  {
                    "type": "actions",
                    "elements": [
                      {
                        "type": "button",
                        "text": { "type": "plain_text", "text": "Review PR", "emoji": true },
                        "style": "primary",
                        "url": "${PR_URL}"
                      },
                      {
                        "type": "button",
                        "text": { "type": "plain_text", "text": "View Logs", "emoji": true },
                        "url": "${WORKFLOW_URL}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
          EOF

          # Check if SLACK_KEY is configured
          if [[ -z "${{ secrets.SLACK_KEY }}" ]]; then
            echo "::warning::SLACK_KEY not configured - skipping Slack notification"
            echo "::endgroup::"
            exit 0
          fi

          # Send to Slack
          RESPONSE=$(curl -s -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer ${{ secrets.SLACK_KEY }}" \
            -H "Content-Type: application/json" \
            -d @/tmp/slack_payload.json)

          if echo "$RESPONSE" | jq -e '.ok == true' > /dev/null 2>&1; then
            echo "‚úÖ [Slack] Tests passed notification sent"
          else
            ERROR=$(echo "$RESPONSE" | jq -r '.error // "unknown"')
            echo "‚ö†Ô∏è [Slack] Failed to send notification: ${ERROR}"
          fi

          echo "::endgroup::"

  ##############################################################################
  # Notify on test failure
  ##############################################################################
  notify-failure:
    name: Notify Tests Failed
    runs-on: ubuntu-latest
    # Only run on failed CI completions
    if: github.event.workflow_run.conclusion == 'failure'

    steps:
      - name: Get PR info and notify Slack
        id: notify
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eu

          BRANCH="${{ github.event.workflow_run.head_branch }}"
          WORKFLOW_NAME="${{ github.event.workflow_run.name }}"
          WORKFLOW_URL="${{ github.event.workflow_run.html_url }}"

          echo "::group::Getting PR info for failed workflow on ${BRANCH}"

          # Find PR for this branch
          PR_JSON=$(gh pr list \
            --repo ${{ github.repository }} \
            --head "${BRANCH}" \
            --base "carto/main" \
            --json number,url,labels \
            --jq '.[0]')

          if [[ -z "${PR_JSON}" || "${PR_JSON}" == "null" ]]; then
            echo "[Failure Notifier] No PR found for branch ${BRANCH}"
            echo "::endgroup::"
            exit 0
          fi

          PR_NUMBER=$(echo "${PR_JSON}" | jq -r '.number')
          PR_URL=$(echo "${PR_JSON}" | jq -r '.url')
          LABELS=$(echo "${PR_JSON}" | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')

          # Only notify for upstream-sync PRs
          if [[ ! "${LABELS}" =~ "upstream-sync" ]]; then
            echo "[Failure Notifier] Not an upstream-sync PR - skipping"
            echo "::endgroup::"
            exit 0
          fi

          # Extract version from branch
          VERSION=$(echo "${BRANCH}" | sed 's|upstream-sync/||')

          echo "[Failure Notifier] PR #${PR_NUMBER}: ${WORKFLOW_NAME} failed"
          echo "::endgroup::"

          echo "::group::Posting failure notification to Slack"

          # Build Block Kit payload for tests failed
          cat > /tmp/slack_payload.json << EOF
          {
            "channel": "${SLACK_CHANNEL_LITELLM}",
            "text": "‚ö†Ô∏è LiteLLM Upstream Sync: Tests Failed",
            "attachments": [
              {
                "color": "#FFA500",
                "blocks": [
                  {
                    "type": "header",
                    "text": {
                      "type": "plain_text",
                      "text": "‚ö†Ô∏è LiteLLM Upstream Sync",
                      "emoji": true
                    }
                  },
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": "*Step 4 of 4: Tests Failed*\n\n‚Ä¢ :x: ${WORKFLOW_NAME} failed\n‚Ä¢ Version: \`${VERSION}\`\n‚Ä¢ PR blocked until fixed"
                    }
                  },
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": "*Action Required*\n‚Ä¢ Check the workflow logs\n‚Ä¢ Fix failing tests\n‚Ä¢ Re-run the pipeline"
                    }
                  },
                  {
                    "type": "context",
                    "elements": [
                      {
                        "type": "mrkdwn",
                        "text": ":book: <${DOCS_URL}|LiteLLM Fork CI Docs>"
                      }
                    ]
                  },
                  {
                    "type": "actions",
                    "elements": [
                      {
                        "type": "button",
                        "text": { "type": "plain_text", "text": "View PR", "emoji": true },
                        "url": "${PR_URL}"
                      },
                      {
                        "type": "button",
                        "text": { "type": "plain_text", "text": "View Logs", "emoji": true },
                        "url": "${WORKFLOW_URL}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
          EOF

          # Check if SLACK_KEY is configured
          if [[ -z "${{ secrets.SLACK_KEY }}" ]]; then
            echo "::warning::SLACK_KEY not configured - skipping Slack notification"
            echo "::endgroup::"
            exit 0
          fi

          # Send to Slack
          RESPONSE=$(curl -s -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer ${{ secrets.SLACK_KEY }}" \
            -H "Content-Type: application/json" \
            -d @/tmp/slack_payload.json)

          if echo "$RESPONSE" | jq -e '.ok == true' > /dev/null 2>&1; then
            echo "‚úÖ [Slack] Tests failed notification sent"
          else
            ERROR=$(echo "$RESPONSE" | jq -r '.error // "unknown"')
            echo "‚ö†Ô∏è [Slack] Failed to send notification: ${ERROR}"
          fi

          echo "::endgroup::"
